Микросервисная архитектура для настройки RabbitMQ в реальных условиях.
-
Шаг 1
-
В файле features.py с помощью цикла сделайте бесконечной отправку вектора признаков и ответов. Добавьте некоторую задержку после каждой итерации, чтобы можно было отслеживать происходящее. Это можно сделать с помощью функции sleep из модуля time (он встроен в Python и не нуждается в установке).
Далее добавьте в каждое сообщение уникальный идентификатор. Чтобы сформировать идентификаторы, можно воспользоваться текущей датой в формате timestamp. Для этого можно применить встроенный в стандартную библиотеку Python модуль datetime:
Далее этот идентификатор можно добавить в передаваемые сообщения перед сериализацией. Например, сообщение, передаваемое в очередь y_true, может выглядеть следующим образом:
Обратите внимание, что теперь сообщения передаются в формате словарей — не забудьте перевести в этот формат и другие микросервисы.
Важно, чтобы признакам, соответствующим им истинным ответам и предсказаниям были присвоены одинаковые ID.

Шаг 2
-
Далее добавьте в ваше приложение логирование метрик.
В папке logs/ создайте файл metric_log.csv. В нём будет храниться таблица со следующими столбцами: id, y_true, y_pred, absolute_error.
Запишите в файл metric.csv имена столбцов, чтобы инициализировать таблицу (обратите внимание, что в CSV-файле элементы таблицы записываются без пробелов):
Файл ./logs/metric_log.csv
Измените файл metric.py, который вы подготовили в этом модуле, таким образом, чтобы скрипт в режиме реального времени записывал в файл metric_log.csv идентификаторы сообщения, истинные метки, предсказания, а также абсолютные ошибки между истиной и прогнозом.
Примечание. Рассчитывайте абсолютные ошибки по формуле:


Важно! Так как сообщения с истинными метками и предсказаниями модели поступают в сервис metric из двух разных очередей, которые работают в асинхронном режиме, для вычисления абсолютных ошибок вам необходимо будет придумать способ сохранения приходящих сообщений перед расчётом абсолютной ошибки.

Например, вы можете записывать приходящие сообщения в соответствующие столбцы DataFrame, а когда в таблице появятся и y_true, и y_pred, соответствующие заданному идентификатору — вычислять абсолютную ошибку модели. Также вы можете придумать свой вариант обработки.

После каждой итерации сервиса features в файле metric_log.csv должна появляться новая запись с соответствующим идентификатором, истинным ответом, предсказанием и ошибкой. Ниже представлен пример содержания этого файла после пяти итераций сервиса features:

Файл ./logs/metric_log.csv


id,y_true,y_pred,absolute_error
1669147134.196809,295.0,221.77392889122234,73.22607110877766
1669147136.824343,153.0,118.44344405446542,34.55655594553458
1669147141.035324,189.0,204.06083656673704,15.060836566737038
1669147148.42061,173.0,200.44085356158348,27.44085356158348
1669147162.280003,154.0,159.34185386962795,5.341853869627954
Шаг 3

Добавьте к вашей архитектуре ещё один сервис — plot. Скрипт с его кодом назовите plot.py. Данный сервис должен в бесконечном цикле читать таблицу metric_log.csv и строить график распределения (гистограмму) абсолютных ошибок. График должен записываться в файл logs/error_distribution.png.

Создайте для нового сервиса Dockerfile, указав в нём инструкции по сборке образа контейнера. Не забудьте добавить все необходимые зависимости, указав их в файле requirements.txt.

После создания самого скрипта микросервиса и инструкций по его сборке добавьте инструкции по его запуску в compose-файл. Продумайте, от каких сервисов зависит сервис plot. Помните, что при запуске сервиса plot необходимо связать локальную директорию logs/ и рабочую директорию контейнера.

В результате работы сервиса в вашей локальной директории logs должен появиться файл error_distribution.png с гистограммой. Гистограмма должна обновляться с каждой итерацией запуска сервиса features. Пример гистограммы:

img

Критерии оценивания

Максимум можно получить за задание 10 баллов

1. Корректная реализация обмена сообщениями через AMQP-протокол (2 балла)

Сервисы работают в режиме бесконечного цикла и обмениваются между собой сообщениями через AMQP-протокол.

2. Введение временной задержки в сервисе features (2 балла) 

В сервисе features предусмотрена временная задержка между отправкой признаков и истинных ответов для случайно выбранного наблюдения из исходной выборки.

3. Присвоение и контроль идентификаторов для сообщений (2 балла)  

Каждое сообщение сопровождается идентификатором, причём этот идентификатор совпадает для признаков, ответов и предсказаний, относящихся к одному и тому же наблюдению из исходной выборки.

4. Запись предсказаний, ответов и разницы в файл metriclog.csv (2 балла)  

Предсказания, ответы и абсолютная разница между ними записываются в файл metric_log.csv в режиме реального времени.

5. Построение гистограммы ошибок (2 балла)

В режиме бесконечного цикла строится гистограмма ошибок на основе логов из файла logs/metric_log.csv. Результат записывается в файл logs/error_distribution.png.

Структура проекта
-
microservice_architecture
    └─features
        └─src
            └─features.py
    └─model
        └─src
            └─model.py
            └─myfile.pkl
    └─metric
        └─src
            └─metric.py


├── docker-compose.yaml
├── features/
│   ├── Dockerfile
│   ├── requirements.txt
│   └── src/
│       └── features.py
├── logs/
│   ├── error_distribution.png
│   └── metric_log.csv
├── metric/
│   ├── Dockerfile
│   ├── requirements.txt
│   └── src/
│       └── metric.py
├── model/
│   ├── Dockerfile
│   ├── requirements.txt
│   └── src/
│       ├── model.py
│       └── myfile.pkl
└── plot/
    ├── Dockerfile
    ├── requirements.txt
    └── src/
        └── plot.py
Описание сервисов
-
Features Service (features/src/features.py):

Загружает датасет о диабете
Генерирует случайные выборки
Отправляет векторы признаков и истинные значения в очереди RabbitMQ
Добавляет уникальные ID сообщений на основе временных меток
Работает в бесконечном цикле с интервалом 10 секунд

Model Service (model/src/model.py):

Загружает предварительно обученную модель из myfile.pkl
Слушает очередь с признаками
Делает предсказания
Отправляет предсказания в очередь предсказаний
Сохраняет ID сообщений для отслеживания

Metric Service (metric/src/metric.py):

Слушает очереди с истинными значениями и предсказаниями
Сопоставляет пары по ID сообщений
Вычисляет абсолютные ошибки
Записывает результаты в logs/metric_log.csv

Plot Service (plot/src/plot.py):

Отслеживает metric_log.csv
Создает гистограммы распределения ошибок
Добавляет статистическую информацию (среднее, медиана)
Сохраняет графики в logs/error_distribution.png
Обновляется каждые 10 секунд

Требования
-
Docker
Docker Compose

Запуск
-
Клонируйте репозиторий:

git clone <url-репозитория>
cd <название-директории>
Запустите сервисы с помощью Docker Compose:

docker-compose up -d

Мониторинг
-
RabbitMQ Management UI: http://localhost:15672 (guest/guest)
Метрики: logs/metric_log.csv
Визуализация распределения ошибок: logs/error_distribution.png
Логи сервисов: docker logs <имя-контейнера>
Docker Compose конфигурация

Сервисы:
-

rabbitmq: Брокер сообщений
Порты: 5672 (AMQP), 15672 (Management UI)
features: Генерация данных
model: Предсказания
metric: Расчет метрик
plot: Визуализация
Все сервисы настроены на автоматический перезапуск и имеют необходимые зависимости.

Формат сообщений
Сообщения отправляются в формате JSON:

{
    "id": 1699541234.567,
    "body": [значение]
}
где:

id: Unix timestamp как идентификатор сообщения
body: Вектор признаков или значение предсказания
Остановка сервисов
docker-compose down
Структура файлов
docker-compose.yaml: Конфигурация Docker Compose
*/Dockerfile: Инструкции сборки контейнеров
*/requirements.txt: Зависимости Python
*/src/*.py: Исходный код сервисов
logs/: Директория для файлов с результатами
metric_log.csv: Метрики и ошибки
error_distribution.png: Визуализация распределения ошибок
